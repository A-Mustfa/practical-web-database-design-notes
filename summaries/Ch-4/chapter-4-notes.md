# Chapter 4

## 🧠 **ما هو Data Modeling؟**

- هو عملية تصميم قاعدة البيانات بشكل مجرد (abstract)، يعني قبل ما نبدأ نكتب كود SQL أو ننشئ الجداول، بنقعد نخطط ونرسم شكل البيانات والعلاقات بينها.

---
## 🎯 **ليه بنعمل Data Modeling؟**

- عشان **نبسّط التعقيد** ونركز بس على البيانات المهمة.
- عشان نقدر **نتفاهم مع العميل أو التيم** ونشوف إذا كده التصميم مناسب ولا لأ.
- عشان لو بدأنا صح، **مش هيحصل كوارث بعدين** في التطبيق أو الأداء.
- زي ما المهندس بيعمل رسومات قبل ما يبني عمارة، إحنا بنرسم "نموذج" للبيانات قبل ما نكتب كود.

---
## 🔁 **الموضوع تكراري (Iterative)**

- يعني مش بنعمل النموذج مرة واحدة وخلاص. لا، بنبدأ مسودة، نعرضها، نعدّل، ونعيد الخطوة دي كذا مرة لحد ما نوصل لأفضل تصميم ممكن.

---
## 🤝 **مشاركة النموذج مع العميل أو التيم**

- ساعات العميل نفسه مش عارف هو محتاج إيه بالضبط.
- لما يشوف النموذج قدامه يبدأ يفهم أكتر ويطلب تعديلاته.
- ده يساعدنا نوضح الأسئلة اللي نسينا نسألها في الأول.

---
## 🛠️ **بعد ما نخلص النموذج...**

- بنبدأ ننفذ قاعدة البيانات في أي نظام إدارة قواعد بيانات (RDBMS) زي MySQL أو SQL Server.
- الجميل إن النموذج ده **ما بيكونش مرتبط بقاعدة بيانات معينة**، يعني ممكن نبدأ على لابتوبنا وننقلها على سيرفر كبير بعدين.

---
## 🧱 **كمان النموذج بيساعد لو عندنا قاعدة بيانات قديمة**

- لو بنشتغل على نظام قديم (Legacy System)، النموذج بيساعدنا نفهم القاعدة دي أحسن بدل ما نقعد نقرأ مئات أسطر الكود.

---
### 📌 مثال واقعي:

تخيل إنك بتصمم موقع بيع منتجات. قبل ما تنشئ جدول `PRODUCTS` و`CUSTOMERS`، بتفكر:

- إيه أنواع البيانات اللي هحتاجها؟
- كل منتج له سعر، وصف، كمية، صح؟
- العميل ممكن يطلب أكتر من منتج؟ آه → يبقى في علاقة بينهم.

بنرسم الكلام ده كمربعات وخطوط (ERD مثلاً)، ونعدل عليه قبل ما نكتب أي كود.

---
## 📌 **Entity Relationship Modeling (ER Modeling)**

هي الطريقة الأشهر لتصميم قواعد البيانات بطريقة منظمة قبل البدء في التنفيذ.

---
## 🧱 مكونات ER Model:

1. **Entities (الكيانات)**
    - تمثل **الأشياء أو الأشخاص أو الأماكن** اللي بنخزن عنها بيانات.
    - مثال: `Book`, `Publisher`.
        
2. **Attributes (الخصائص)**
    - هي **المعلومات الخاصة بكل كيان**.
    - مثال:
        - كيان `Book` عنده خصائص: `Title`, `Author`, `ISBN`, `PublisherID`.
        - كيان `Publisher` عنده خصائص: `Name`, `Address`.
            
3. **Relationships (العلاقات)**
    - تحدد **إزاي الكيانات مرتبطة ببعض**.
    - مثال: كل كتاب له ناشر → علاقة بين `Book` و `Publisher`.

---
## 🛍️ **مثال على Online Bookstore**

### ✳️ الكيانات:

- **Books**
- **Publishers**
### ✳️ الخصائص:

- **Books:**
    
    - `BookID` (Primary Key)
    - `Title`
    - `Author`
    - `ISBN`
    - `PublisherID` (Foreign Key)
    
- **Publishers:**
    
    - `PublisherID` (Primary Key)
    - `Name`
    - `Address`
    
### ✳️ العلاقة:

- كل **Book** مرتبط بـ **Publisher** واحد.
- **Publisher** ممكن يكون له أكتر من **Book**.

---
## 🧠 ملاحظات مهمة:

- الشكل الظاهري للـ ER Diagram يختلف حسب الأداة (Visio، Draw.io...).
- لكن المفهوم الأساسي دايمًا موجود: **كيانات + خصائص + علاقات**.
- النموذج بيساعدك تفهم المشروع كويس قبل كتابة أي كود.

---
## 📌 **Entities (الكيانات)**

### ✅ التعريف:

- الكيان (Entity) هو **تمثيل مجرد لشيء حقيقي في العالم الواقعي**.
- في قاعدة البيانات، يتم تمثيل كل كيان **بجدول**.

---
## 🧠 ملحوظة هامة:

- كل **كيان = جدول**
- وكل **خاصية = عمود**
- وكل **صف داخل الجدول = صف بيانات حقيقي يمثل كيانًا فرديًا**

---
## 📌 **Attributes (السمات / الخصائص)**
### ✅ التعريف:
- **Attributes** هي الخصائص أو السمات التي تميز الكيانات (Entities).
- في قواعد البيانات، يتم تمثيل الـ Attributes على شكل **أعمدة (Columns)** داخل الجداول.

---
### 🧱 أمثلة:

#### كيان `Books` يحتوي على السمات التالية:

- `ISBN` (رقم فريد للكتاب)
- `PublisherID` (يشير إلى الناشر)
- `Title` (عنوان الكتاب)
- `Author` (اسم المؤلف)

#### كيان `Publishers` يحتوي على:

- `PublisherID`
- `Name`
- `Address`

---
### 🧠 ملاحظات مهمة:

- **PK (Primary Key):** السمة الأساسية التي تُميز كل سجل.
- **FK (Foreign Key):** سمة تشير إلى كيان آخر (مثل علاقة بين كتب وناشرين).
    - يتم ترقيمها (مثلاً: `FK1`, `FK2`) فقط للتمييز.
---

## 🔗 **Relationships (العلاقات بين الكيانات)**
### ✅ التعريف:

- **Relationship** تعني كيفية ارتباط **كيانين** (Entities) ببعضهما البعض.
- في المثال: كل **Publisher** يمكن أن يصدر **عدة كتب** → العلاقة بين `Publishers` و `Books`.

---
### 🧱 في الرسم التوضيحي:

- يتم تمثيل العلاقة **بخط يصل بين الكيانين**.
- الشكل الموجود على طرفي الخط يوضح **نوع العلاقة** (Cardinality) و**إجباريتها** (Optionality).

---

## 📌 Cardinality (التعددية في العلاقة)

> في مثالنا:

- كل **Book** مرتبط بـ **Publisher واحد فقط**.
- كل **Publisher** ممكن يكون عنده **كتب كتير**.
- ناشر واحد ل عدة كتب (One-Many)

---

## 📌 Optionality (اختيارية العلاقة)

| الرمز | المعنى                                          |
| ----- | ----------------------------------------------- |
| ○     | **Optional** (اختياري – ممكن ما يكونش في علاقة) |
| \|\|  | *Mandatory*(إالزاميه - لازم يكون موجود)         |

> في المثال:

- كل **Book لازم يكون له Publisher** → لذلك العلاقة من جهة `Books` إلى `Publishers` هي **mandatory**.
- أما **Publisher** ممكن ما يكونش عنده كتب حاليًا → العلاقة من جهته **optional**.

---
### 🧠 ملاحظات إضافية:

- العلاقة دي تسمى **One-to-Many** (واحد إلى متعدد).

---

## 🔁 Common Structures in Database Design

### 🎯 الهدف:

- تكوين مكتبة ذهنية من **أشكال العلاقات الشائعة** بين الجداول (Entities).
- تستخدم هذه العلاقات لتصميم نماذج قواعد بيانات فعالة وقابلة للتطوير.

---
## 📌 العلاقات الشائعة حسب التكرار:

|الترتيب|نوع العلاقة|الوصف|
|---|---|---|
|1️⃣|One-to-Many|الأكثر شيوعًا|
|2️⃣|Many-to-Many|شائعة ولكن تنفيذها أصعب|
|3️⃣|One-to-Many Recursive|علاقة داخل نفس الجدول|
|4️⃣|Many-to-Many Recursive|علاقة متعددة داخل نفس الجدول|
|5️⃣|One-to-One|نادرة نسبيًا|

---
### 1️⃣ One-to-Many

#### 🧠 التعريف:

- **صف واحد** في الجدول الأب مرتبط بـ **عدة صفوف** في الجدول الابن.
- الطفل (Child) مرتبط بأب واحد فقط.

#### 🧾 مثال 1:

- **Category ↔ Products**
    
    - كل Category تحتوي على Products.
    - كل Product ينتمي إلى Category واحدة.

#### 🧾 مثال 2:

- **Customer ↔ Orders**
    
    - كل عميل يمكن أن يكون له أكثر من طلب.
    - الطلب الواحد دائمًا تابع لعميل واحد فقط.

#### 🔎 ملاحظات:

- يمثل بالـ **foreign key** في الجدول الابن.
- يمكن أن تكون العلاقة "one-to-zero-or-many"، لكن يشار إليها اختصارًا بـ One-to-Many.
- سهلة في التنفيذ على RDBMS مثل MySQL وPostgreSQL.

---

### 2️⃣ Many-to-Many

#### 🧠 التعريف:
- صف في جدول يمكن أن يكون مرتبطًا بعدة صفوف في جدول آخر **والعكس صحيح**.

#### ❌ غير مدعومة مباشرة:
- لا يمكن تنفيذها مباشرة في RDBMS.
- نحتاج إلى **جدول وسيط (Associative Table)** يمثل العلاقة.

#### 🧾 مثال:
- **Orders ↔ Products** باستخدام جدول `OrderItems` كوسيط.

#### 👇 بنية الجداول:
- **Orders** ← OrderID, CustomerID
- **Products** ← ProductID, Name
- **OrderItems** ← OrderID (FK), ProductID (FK), Quantity, Price

#### 🧠 فوائد جدول العلاقة:
- يسمح بربط منتج واحد بعدة طلبات والعكس.
- يمكنه تخزين **بيانات إضافية** (مثل الكمية والسعر).

#### 🔁 مثال آخر:
- **Users ↔ Groups** باستخدام جدول `UserGroup`.

#### ✅ خطوات تحديد نوع العلاقة:

استخدم جمل مثل:
- "هل يمكن للمستخدم أن ينتمي لأكثر من مجموعة؟"
- "هل يمكن للمجموعة أن تحتوي على أكثر من مستخدم؟"

لو الإجابتين نعم → Many-to-Many.

---
## 🔁 One-to-Many Recursive Relationships

### ✅ التعريف:

- علاقة بين الصفوف **داخل نفس الجدول**.
- تُستخدم لتمثيل **الهياكل الهرمية (tree structures)** مثل:
    - تصنيف المنتجات.
    - الهيكل الإداري للشركة.

---

### 📚 أمثلة شائعة:

#### 📌 1. تصنيفات المنتجات (Product Categories)

- جدول: `Categories`
- الأعمدة المهمة:
    - `CategoryID`: المفتاح الأساسي.
    - `ParentCategory`: مفتاح أجنبي يشير إلى `CategoryID`.

#### 🧠 كيف تُبنى الشجرة؟

- الفئات التي لها `ParentCategory = NULL` تكون **في قمة الشجرة**.
- كل فئة تشير إلى الأب من خلال `ParentCategory`.

#### ⚠️ مشاكل محتملة:

- ممكن يحصل **خلل منطقي** لو عينت أب للفئة يكون أصلاً أحد الأبناء.
- قاعدة البيانات مش هتكتشف ده لأنه ما بيخالفش الـ FK rule.
- ✅ الحل: تحقق برمجياً أو استخدم **Triggers** تمنع هذا النوع من التكرار غير المنطقي.

---
#### 📌 2. الهيكل الإداري للموظفين (Employee Hierarchy)

- جدول: `Employees`
- الأعمدة:
    - `EmployeeID`: المفتاح الأساسي.
    - `Manager`: مفتاح أجنبي يشير إلى `EmployeeID`.

#### 🧠 لماذا `Manager` يجب أن يسمح بـ `NULL`؟

- لأن الموظف في أعلى الهرم (مثلاً CEO) **ليس له مدير**.

---
### 🛠️ نصائح عند استخدام Recursive Relationships:

|النقطة|التفسير|
|---|---|
|السماح بـ NULL في الـ FK|لأن أعلى مستوى في الشجرة لا يشير لأي عنصر آخر.|
|فحص التكرار العكسي|تأكد ألا يُعين الابن كأب نفسه أو لأسلافه|
|استخدام Triggers|لضمان سلامة العلاقات الهرمية|

---
## 🧠 التعامل برمجيًا مع Recursive Relationships

### ✅ الفكرة الأساسية:

- العلاقات التكرارية زي شجرة الفئات (categories tree) تحتاج **تكرار (recursion)** للتنقل بين المستويات.
- يمكن تصفح الشجرة بطريقتين:
    1. **من الأسفل للأعلى**: سهل – استعلام واحد باستخدام FK.
    2. **من الأعلى للأسفل**: أصعب – نحتاج دالة تستدعي نفسها (Recursive Function).

---
## 📄 مثال Pseudo-Code: استرجاع شجرة التصنيفات

```pseudo
// Step 1: استرجاع كل الفئات
Recordset = DBQuery("SELECT * FROM CATEGORIES")

// Step 2: استدعاء دالة التكرار من المستوى الأعلى (Parent = 0)
traverseTree(Recordset, 0)

Function traverseTree(pRecordset, pDepth)
  For each CurrentRow in pRecordset
    Print CurrentRow // عرض بيانات الصف الحالي
    // استرجع الأطفال التابعين لهذه الفئة
    newRecordset = DBQuery("SELECT * FROM CATEGORIES WHERE ParentCategory = " + CurrentRow("CategoryID"))
    // استدعاء الدالة مرة أخرى للأطفال
    traverseTree(newRecordset, pDepth + 1)
  End For
End Function
```

---

### 📌 لماذا نمرر `pDepth` للدالة؟

- عشان نتحكم في **المسافة البادئة (indentation)** لكل مستوى.
- مثال: نضيف `--` أو مسافة حسب العمق لتمييز المستويات بصريًا.

---
### ⚠️ ملاحظات مهمة:

|⚠️ التحذير|💡 الحل|
|---|---|
|**قد تسبب استعلامات كثيرة جدًا (N+1 queries)** إذا الشجرة عميقة جدًا أو المستخدمين كثير|✅ احفظ النتائج مؤقتًا (Cache) باستخدام XML أو JSON|
|**أداء الموقع ممكن يتأثر مع عدد مستخدمين كبير**|✅ حمّل الشجرة مرة واحدة في البداية واستخدمها لاحقًا في الذاكرة|
|**التعامل مع البيانات في شكل Tree برمجيًا معقد أحيانًا**|✅ حمّلها كـ Flat List، وبعدين ابني الشجرة بالكود (DOM أو JS أو XSLT...)|

---
## 🌳 بدائل وحلول فعالة:

- **استخدام XML أو JSON** لتخزين بنية الشجرة وتحميلها مرة واحدة.
- **استخدام XSLT** لو كنت بتتعامل مع XML – لأنه قوي جدًا في التعامل مع recursion.
- **عرض شجرة مصنفة بشكل ديناميكي باستخدام JavaScript** من مصدر بيانات مخزن مسبقًا (مثلاً API بتبعت شجرة JSON جاهزة).

---
## 🔄 Many-to-Many Recursive Relationship
### ✅ التعريف:

- العلاقة التكرارية (recursive) = علاقة مع **نفس الجدول**.
- many-to-many = عنصر واحد مرتبط بـ **عدة عناصر**، وكل عنصر ممكن يكون مرتبط **بعناصر أخرى**.
- **مثال عملي**: منتج (زي "Combo Deal") مكوّن من منتجات أخرى (زي "Summer Tracksuit" و "Winter Tracksuit").

---
### 📊 الكيانات المستخدمة:

|الجدول|الوظيفة|
|---|---|
|`Products`|يحتوي على المنتجات العادية والـBundles أيضًا|
|`ProductBundles`|جدول وسيط (associative table) يربط منتج بمنتجات أخرى|

---
### 📌 الشكل العام:

- المنتج "Tracksuit Combo Deal" له `ProductID = 5`
- المنتج يحتوي على:
    - `ProductID = 3` → "Summer Tracksuit"
    - `ProductID = 4` → "Winter Tracksuit"
- لذلك جدول `ProductBundles` يحتوي على:

|BundleID|BundledProductID|
|---|---|
|5|3|
|5|4|

> ✅ نفس المنتج ممكن يظهر كـ "bundle" أو "عنصر داخل bundle" حسب السياق.

---
### 📈 فوائد هذا النموذج:

|الميزة|التوضيح|
|---|---|
|✅ **مرونة كبيرة**|ممكن تعمل bundling لأي عدد من المنتجات|
|✅ **Bundles داخل Bundles**|يعني combo ممكن يحتوي على combo تاني|
|✅ **نموذج موحد**|كل المنتجات سواء كانت مفردة أو bundles موجودة في نفس الجدول (`Products`)|

---
### ⚠️ ملاحظات مهمة:

1. **تجنب التكرار الدائري (Circular Reference)**:
    - ممنوع أن bundle يحتوي نفسه.
    - ممنوع يكون bundle A يحتوي B وB يحتوي A.
    - الحل: تحقق من وجود الحلقات قبل الإدخال، باستخدام **الكود أو triggers**.
    
2. **سهولة التوسع**:
    - يمكن إضافة حقول لاحقًا في `ProductBundles` مثل الكمية أو الخصم أو الترتيب داخل الباندل.
    
3. **تطبيقات كثيرة في الواقع**:
    - شركات الإلكترونيات (جهاز كمبيوتر مكوّن من ماذربورد، RAM، CPU...)
    - مواقع التجارة (buy 1 get 1، combo deals، gift sets)

---
### 🎯 ملخص سريع:

|الخاصية|القاعدة|
|---|---|
|العلاقة|بين `Products` و `Products` عبر `ProductBundles`|
|النوع|many-to-many + recursive|
|الهدف|نمذجة التجميعات والـcombos|
|التحدي|التأكد من عدم حدوث recursion لا نهائي (self-referencing)|

---
## 🔗 One-to-One Relationship
### ✅ التعريف:
- معناها إن **كل صف في جدول A يرتبط بصف واحد فقط في جدول B**، والعكس صحيح.
- العلاقة بتكون **واحد لواحد فقط** في الاتجاهين.

---
### 🧩 النوعين الرئيسيين:
1. **Actual One-to-One**
    - فعلاً العلاقة طبيعتها واحد لواحد.
    - مثال: جدول `User` مرتبط بجدول `UserProfile` — كل مستخدم له ملف واحد فقط.
    - ممكن يتم فصل الجداول لأسباب:
        - الأمان (فصل بيانات حساسة).
        - الأداء (تحميل بيانات ثقيلة فقط عند الحاجة).
        - التنظيم (تقسيم البيانات لمناطق منطقية).

2. **Subtype/Supertype**
    
    - بنسميه أحيانًا Inheritance في تصميم الكيانات.
    - مثال: جدول `Employee` ممكن يكون له `Manager` أو `Technician` كنوع فرعي.
        - `Employee` = Supertype
        - `Manager` و `Technician` = Subtypes
    - كل سجل في الجدول الأب (supertype) يكون له سجل واحد فقط في أحد الجداول الفرعية.

---
### ⚠️ ملاحظات مهمة:

|الملاحظة|التوضيح|
|---|---|
|العلاقة نادرة لكنها **مهمة في بعض السيناريوهات**|خصوصًا لما يكون في بيانات نادرة الاستخدام أو حساسة|
|لازم يكون فيه مفتاح مشترك|غالبًا `Primary Key` في الجدولين يكون نفس القيمة|
|ممكن تُستخدم لفصل الكيانات المنطقية|زي فصل `Users` و `Settings` أو `Employee` و `Benefits`|

---
### 📌 مثال سريع:
#### جدول `User`

|UserID|Username|
|---|---|
|1|Ahmed|
|2|Fatma|
#### جدول `UserSettings`

|UserID|Theme|Language|
|---|---|---|
|1|dark|en|
|2|light|ar|

> ✅ كل `UserID` في `UserSettings` يظهر مرة واحدة فقط — علاقة One-to-One.

---
### 🔹 Actual One-to-One Relationships
#### ✅ التعريف:

- علاقة مباشرة بين **صف واحد في جدول A وصف واحد في جدول B**.
- مثال: كل قسم له مدير واحد فقط، وكل مدير مسؤول عن قسم واحد فقط.
#### 📌 في المثال:

- `Departments.DepartmentManager` ← مفتاح خارجي إلى `Employees.EmployeeID`.
- العلاقة One-to-One واضحة:
    - قسم الأحذية ↔ المدير فلان.
    - المدير ده مش ممكن يدير أكتر من قسم.
#### ⚠️ ملاحظات مهمة:

|نقطة|شرح|
|---|---|
|تشبه علاقة One-to-Many في الشكل|لكن يُسمح فقط بصف واحد على الجانب التابع|
|استخدامها نادر|لأنه قليل جدًا تكون العلاقة محددة كده في الواقع|
|الأفضلية للمرونة|عادة الأفضل استخدام One-to-Many عشان تسهّل التعديل لاحقًا لو تغيرت المتطلبات|

---
### 🔸 Subtype / Supertype Relationships

#### ✅ التعريف:

- تُستخدم لما يكون عندنا **كيان رئيسي** (supertype) و**أنواع فرعية** (subtypes) لها خصائص مميزة.
- كل صف في الجدول الأساسي **يرتبط بصف واحد فقط** في جدول فرعي.

#### 📌 مثال الملفات:
- `Items` = الكيان العام (ملف أو مجلد).
    
- `Files` = كيان فرعي لو العنصر ملف فقط.
    
- العلاقة One-to-One: كل صف في `Items` ممكن يكون له صف في `Files` (أو لا).
#### ⚙️ التنظيم حسب عدد الأنواع الفرعية:

|الحالة|مكان المفتاح الخارجي|
|---|---|
|نوع فرعي واحد|المفتاح في الجدول الأب (supertype)|
|أكثر من نوع فرعي|المفتاح في كل جدول فرعي|
#### 📌 مثال تعدد الأنواع:

- `Employees` ← الجدول الرئيسي
    
- `ContractEmployees`, `SalariedEmployees` ← النوعين الفرعيين
    
- المفتاح `EmployeeID` موجود كـ PK + FK في كل جدول فرعي
#### ⚠️ ملاحظات:

- ممكن يحصل **تكرار غير مرغوب** (موظف موجود في النوعين).
- لتجنب ده، استخدم **Check Constraint** أو **Logic في التطبيق**.

---
#### 🧠 الخلاصة:

|نوع العلاقة|متى تستخدم؟|الميزة|
|---|---|---|
|Actual One-to-One|عند وجود ارتباط حقيقي وثابت بين كيانين|تنظيم البيانات|
|Subtype/Supertype|عند وجود سمات مشتركة وبعض الاختلافات بين الكيانات|إعادة استخدام البيانات وتنظيمها|

---
## Integrity 

### ✅ الفكرة العامة:

بدل ما تعتمد على الكود في التطبيق (frontend أو backend) عشان يمنع البيانات الغلط، **تحط القواعد جوا قاعدة البيانات نفسها**.
ليه؟

- لأن ممكن أكتر من تطبيق يوصل لقاعدة البيانات (ويب – API – أدوات تحليل...).
- وممكن المطور يغلط أو ينسى يتحقق من صحة البيانات.
- لكن قاعدة البيانات مش هتسمح بأي إدخال أو تعديل مخالف للقواعد اللي انت حاططها.

---
### 🔒 الأنواع الثلاثة من القيود اللي بنستخدمها:

#### 1.   **Entity Integrity – سلامة الكيانات**
- بتضمن إن **كل كيان (صف)** في الجدول يكون **معرّف بشكل فريد**.
- يعني لازم يكون فيه **Primary Key** في كل جدول.
    - ومن شروط الـ PK:
        - لا يمكن يكون فيه **null**
        - لا يمكن يكون **مكرر**
    ✅ مثال: جدول الموظفين لازم يكون لكل موظف رقم ID فريد.
    

---

#### 2. **Attribute Integrity – سلامة الخصائص**
    
- يعني التحقق من صحة **كل قيمة في العمود** (Attribute).
- أمثلة:
    - نوع البيانات: لازم المرتب يكون رقم مش نص.    
    - استخدام `NOT NULL`: يمنع ترك الخانة فاضية.    
    - استخدام `CHECK`: زي مثلًا `CHECK (Salary > 0)`    
    ✅ مثال: التأكد إن تاريخ الميلاد مش بعد تاريخ اليوم.
    

---

#### 3. **Relational Integrity – سلامة العلاقات**
- ده مرتبط بالعلاقات بين الجداول.
- أشهر مثال: **Foreign Key**
     - لازم كل قيمة في العمود اللي بيربط جدول بجدول تاني، تكون موجودة فعلًا في الجدول المرتبط. 
✅ مثال: لو جدول `Orders` فيه `CustomerID`، لازم الـ `CustomerID` يكون موجود فعلًا في جدول `Customers`.
    

---
### 💡 ملحوظة مهمة:

> وضع قيود التكامل في قاعدة البيانات = ضمان دائم ضد الأخطاء، **بغض النظر مين بيعدل الداتا أو منين**.

---
### ✅ ما المقصود بـ Entity Integrity؟

- كل **صف** في الجدول لازم يكون له **هوية مميزة**.
- هذه الهوية هي الـ **Primary Key**، واللي غالبًا بنستخدمه علشان نربط الجدول ده بجداول تانية.

---
### 🔑 شروط الـ Primary Key:
#### في حالة المفتاح الأساسي **المكون من عمود واحد**:
1. لازم تكون القيم **فريدة (Unique)**.
2. لا يمكن تحتوي على **NULL**.

#### في حالة المفتاح الأساسي **المركّب (Composite Key)**:
1. لازم تكون **مجموعة الأعمدة مع بعض** فريدة.
2. ولا واحد من الأعمدة دي يكون فيه **NULL**.

---
### ⚠️ ليه الـ NULL ممنوع في الـ Primary Key؟

- لأن **NULL مش قيمة فعلية**.
- ومش ممكن نقول إن `NULL = NULL`، لأن دي مش مقارنة منطقية.
- وبالتالي، ما نقدرش نستخدم NULL في شيء المفروض يكون فريد ومقارن.

✅ يعني:
> لو سمحت لـ NULL يدخل في الـ PK، ما تقدرش تضمن إنه فريد، لأن القاعدة مش هتعرف تقارن بينهم.

---
### 📌 مثال عملي:

|EmployeeID (PK)|Name|
|---|---|
|101|Sarah|
|102|Ahmed|
|NULL ❌|Mona|

- الصف الأخير غير صالح، لأن الـ PK لا يمكن يكون NULL.

---

### المفاتيح المركبة (Concatenated / Composite Keys)

- مش لازم الأعمدة نفسها تكون فريدة **بشكل فردي**، لكن **مجموعهم معًا لازم يكون فريد**.
### 🧠 مثال من الفقرة:

|**Author**|**Title**|**Publisher**|
|---|---|---|
|J. Smith|Advanced Spoonbending|XYZ Press|
|J. Smith|Elementary Spoonbending|XYZ Press|
|R. Jones|Top Golf Holes|ABC Books|
|S. Robinson|Top Golf Holes|Greenkeeper Publishing|

- ولا واحد من الأعمدة دي فريد لوحده.
- لكن مجموع التلاتة في كل صف بيكوّن **مفتاح فريد**.

---

### ✅ ثانيًا: الفرق بين **Natural Keys** و **Surrogate Keys**

#### 🌿 Natural Key = مفتاح طبيعي (بيمثل بيانات حقيقية)

- زي: ISBN، عنوان، رقم بطاقة.
- واضح وسهل للفهم.
- ممكن يحصل فيه تكرار مستقبلي (زي لما ينزل طبعة جديدة بنفس الاسم بس بسعر مختلف).

⚠️ **المشكلة؟**

- أحيانًا نضطر نكسر القاعدة عشان حدث غير متوقع زي:
    - نفس الكتاب بإصدار جديد.
    - بيانات مش كاملة أو بدون معرف زي ISBN.
    - بيانات مستعملة بتدخل النظام.

---

#### 🔑 Surrogate Key = معرف داخلي (غالبًا رقم تسلسلي ID)

- بيتم توليده داخل قاعدة البيانات.
- ملوش معنى حقيقي للمستخدم.
- بيضمن الفريدة وسهل الاستخدام.

✅ **الحل المثالي؟**

- استخدام **Surrogate Key** كمفتاح أساسي.
- واستخدام الـ ISBN أو أي معرف طبيعي كمجرد **عمود عادي** عليه قيد `UNIQUE` إن لزم الأمر.

---
## 💬 خلاصة:

| المعيار        | المفتاح الطبيعي (Natural Key) | المفتاح البديل (Surrogate Key) |
| -------------- | ----------------------------- | ------------------------------ |
| سهل الفهم      | ✅                             | ❌                              |
| عرضة للتكرار   | ✅                             | ❌                              |
| مناسب للعلاقات | ❌ (قد يسبب مشاكل أحيانًا)     | ✅                              |
| شائع في الواقع | ❌ (مفضل نظريًا فقط)           | ✅ (الأكثر استخدامًا عمليًا)    |

---
## ✅ ما هو الـ **Surrogate Key**؟

- عمود يتم توليده تلقائيًا داخل قاعدة البيانات.
- لا يمثل معلومة حقيقية للمستخدم (زي اسم أو كود منتج).
- الغرض منه هو **ضمان التفرد (uniqueness)** وسهولة العلاقات بين الجداول.

---

## 🔢 أنواع Surrogate Keys:

### 1. **Numeric Sequence Key** (المفاتيح الرقمية التسلسلية)

- الأكثر شيوعًا.
- يبدأ من 1 ويزيد تلقائيًا.
- سهل الاستخدام وسريع.

|قاعدة البيانات|النوع المستخدم|
|---|---|
|MS Access|AutoNumber|
|SQL Server|`IDENTITY`|
|MySQL|`AUTO_INCREMENT`|
|Oracle|`SEQUENCE`|
|PostgreSQL|`SERIAL` أو `SEQUENCE`|

> 📌 هنتعلم استخدامه عمليًا في Chapter 6.

---

### 2. **GUID – Globally Unique Identifier**

- مفتاح طويل ومعقد (زي `550e8400-e29b-41d4-a716-446655440000`)
- مضمون إنه يكون **فريد حتى بين قواعد بيانات مختلفة**.
- مفيد في:
    - أنظمة النسخ الموزعة (Replication).
    - إخفاء الـ ID الحقيقي عن المستخدم (لحماية البيانات من التخمين).

|قاعدة البيانات|الدعم|
|---|---|
|SQL Server|نعم (`uniqueidentifier`)|
|Access|نعم (`Replication ID`)|
|Oracle|ممكن باستخدام `SYS_OP_GUID()`|
|PostgreSQL|عبر مكتبة إضافية|

> ⚠️ أقل كفاءة من الأرقام، ومش مفضل إلا لو فعلاً محتاجه (زي حالات الأمان أو اللامركزية).

---

## 🔒 لماذا نستخدم GUIDs أحيانًا بدل الأرقام؟

- لتقليل خطر **تخمين المعرفات (IDs)** من طرف المستخدم.
    - مثلًا: لو عندك رابط زي `view_user.asp?userid=463`، ممكن أي حد يجرب `464، 465...`
    - أما `view_user.asp?userid=550e8400-e29b...` → صعب يتخمن.

---
## ✅ ممارسات شائعة:

|عنصر|نصيحة|
|---|---|
|اسم العمود|دايمًا سمه `UserID` أو `UserGUID` حسب نوع الـ Key|
|التكرار|لا تضيف مفتاح بديل جديد لو عندك فعلاً مفتاح مركب صالح|
|Timestamp|❌ لا يُفضّل استخدامه كمفتاح، ممكن يتكرر|

---
## 💬 الخلاصة:

|النوع|المزايا|العيوب|
|---|---|---|
|Numeric Key|بسيط، سريع، فعال|يمكن تخمينه|
|GUID|فريد عالميًا، آمن ضد التخمين|أطول، أبطأ في الفهرسة والبحث|

---
## 💡 **شرح مبسط للفكرة**

### 🟥 لا تستخدم Surrogate Key في حالتين أساسيتين:

### 1. ✅ **لما يكون المفتاح الطبيعي (Natural Key) كافي وواضح ومش هيتكرر**

#### مثال:

#### `UserGroup` (جدول ربط Many-to-Many بين `User` و `Group`)

- الجدول بيستخدم مفتاح مركب (Composite Key) مكوّن من:
    
    - `UserGUID` (FK)
    - `GroupID` (FK)
- وده منطقي جدًا لأن:
    - المستخدم ميقدرش يدخل نفس الجروب مرتين.
    - كل مجموعة علاقات بين مستخدم وجروب فريدة بالفعل.

- **إضافة Surrogate Key هنا (زي UserGroupID)** هتبقى مضيعة:
    - هتزود **index زيادة**
    - وهتسبب overhead وقت الإدخال (INSERT)


---
### 2. ✅ **لو الـ Natural Key هيوفر علينا `JOIN` في الاستعلامات**

#### مثال:

#### `Countries` و `Customers`

|Intelligent Key|Surrogate Key|
|---|---|
|Customers.Country = 'Egypt'|Customers.CountryID = 4|

##### ⬅️ **الاستعلام بيكون أبسط:**

```sql
-- Intelligent Key (no JOIN)
SELECT CustomerName, CountryName FROM Customers;

-- Surrogate Key (JOIN required)
SELECT c.CustomerName, co.CountryName
FROM Customers c
JOIN Countries co ON c.CountryID = co.CountryID;
```

- في Lookup tables بسيطة (زي الدول، أو المحافظات)، ممكن استخدام الـ Natural Key يكون أكفأ وأسهل.

---
## 📌 الخلاصة:

|الحالة|استخدم Surrogate Key؟|
|---|---|
|علاقة many-to-many (جدول ربط)|❌ لأ|
|Lookup values صغيرة وثابتة|❌ لأ|
|بيانات ممكن تتكرر أو تتغير|✅ نعم|
|مفاتيح مركبة معقدة|✅ نعم|
|أمان أو تشفير البيانات|✅ نعم (خاصة مع GUIDs)|

---
## ✅ **ملخص مفهوم Attribute / Domain Integrity**

### 🔹 المقصود:
- ضمان إن كل **عمود (Attribute)** في الجدول يحتوي فقط على **قيم منطقية ومسموح بيها** (القيم دي بنسميها **"الدومين"** بتاع العمود).

---
## 🔧 **إزاي نحدد الـ Domain؟**
مش دايمًا هنلاقي كل حاجة مكتوبة، لكن بنعرفها من:

1. **سؤال العميل / المستخدم النهائي:**
    - "ينفع تخزن الجنس Unknown؟"
    - "الوصف محتاج كام حرف؟"
    - "السعر بكام رقم عشري؟"

2. **خبرتك كمصمم قاعدة بيانات:**
    - بعض القواعد العامة والخبرة السابقة.

---
## 🧱 **وسائل فرض الـ Domain Integrity في الـ DBMS**

أغلب قواعد البيانات مش بتسميها explicitly "Domain"، لكن بتوفر أدوات تساعدك تفرض القواعد دي:

|الأداة|دورها في فرض الـ Domain|
|---|---|
|`Data Type`|نوع البيانات المناسب (رقم؟ نص؟ تاريخ؟)|
|`Length`|الطول المسموح به (زي varchar(100))|
|`Constraints`|زي CHECK أو UNIQUE أو PRIMARY KEY|
|`Optionality`|هل القيمة ممكن تكون NULL؟|
|`Default Value`|قيمة افتراضية لو المستخدم مدخلش حاجة|

---

## ⚖️ **3 عوامل لازم توازن بينهم عند اختيار النوع والطول:**

1. **الكفاءة:**
    - اختار أقل نوع وطول ممكن عشان **توفر مساحة وتزود الأداء**.
    
2. **الجاهزية:**
    - خلي الداتا تخرج من الداتابيز **بصيغة مناسبة للتطبيق على طول** (يعني ما تتطرش تعمل parsing كتير في الكود).
    
3. **المرونة المستقبلية:**
    - توقع التغييرات المستقبلية وادرس تأثيرها. أحيانًا تستخدم نوع أطول شوية احتياطيًا.

---

## 🧠 **مثال عملي من الجداول اللي اتكلم عنها:**

|العمود|قاعدة الدومين الممكنة|
|---|---|
|`SecurityCode`|لازم يكون 4 حروف بالضبط|
|`PricePaid`|رقم عشري بـ 2 رقم عشري مثلاً|
|`Customer.Gender`|يا إما M أو F أو Unknown|
|`Customer.PhoneNumber`|لا يسمح بحروف، وربما طول ثابت|

---

## 💡 ملاحظات إضافية:

- ممكن تعتبر **Domain Integrity = قواعد النوع والصيغة والطول لكل عمود**.
- أدوات النمذجة الحديثة زي Visio أو MySQL Workbench بتسمحلك تختار "Generic types" وبتحولها تلقائيًا حسب نوع القاعدة لما تعمل "Forward Engineering".

---
## ✅ **ملخص أنواع البيانات (Data Types)**

### 1. **INTEGER**

- رقم صحيح بدون فاصلة عشرية.
- الحجم المعتاد: 32 بت → المدى من -2,147,483,648 إلى +2,147,483,647.
- بعض اللغات (زي VBScript) بتدعم فقط 16 بت → خلي بالك من **فرق الحجم بين لغة البرمجة وقاعدة البيانات**.
- ⚠️ احذر من **Overflow** لو ما أخدتش بالك من الفروق.

---
### 2. **CHARACTER Types**
SQL-92 بيقدم 3 أنواع:

|النوع|الشرح|
|---|---|
|`CHAR`|حرف واحد.|
|`CHAR(n)`|نص بطول ثابت n. لو النص أقصر، يتكمل بمسافات.|
|`VARCHAR(n)`|نص بطول متغير بحد أقصى n. يخزن فقط الأحرف الفعلية.|

**المقارنة:**

- `CHAR(n)` أسرع في التعديل (ما بيحتاجش نقل بيانات)، لكنه يهدر مساحة لو البيانات قصيرة.
- `VARCHAR(n)` أفضل لمعظم الحالات العملية خصوصًا لو البيانات غير ثابتة الطول.

> مثال: لو عندك عمود يقبل من 1 إلى 100 حرف، `VARCHAR(100)` أفضل بكتير من `CHAR(100)`.

---
### 3. **DECIMAL**

- رقم عشري **بدقة ثابتة**.
- الصيغة: `DECIMAL(p, s)`
    - `p`: Precision = إجمالي عدد الأرقام.
    - `s`: Scale = عدد الأرقام بعد العلامة العشرية.
- مثال: `157.4568` → precision = 7، scale = 4
- كود الإنشاء:
```sql
CREATE TABLE SomeTable (
  DecimalNumber DECIMAL(7, 2)
);
```

---
### 4. **FLOAT / REAL / DOUBLE / MONEY**

- أرقام عشرية لكن **بدون دقة ثابتة** (Floating point).
- مفيدة لما مش فارق معاك عدد الأرقام الدقيقة.
- تختلف من قاعدة بيانات للتانية:
    - مثال: `MONEY` في PostgreSQL = `DECIMAL(9,2)`
    - نفس النوع في SQL Server = `DECIMAL(19,4)`

> ⚠️ لا تستخدم `FLOAT` لو محتاج دقة ثابتة (زي في أسعار المنتجات)، استخدم `DECIMAL`.

---

### 5. **DATETIME**

- معظم الـ RDBMS بتدعم نوع مركب يخزن **التاريخ + الوقت** معًا.
- SQL standard عنده `DATE` و `TIME` منفصلين.
- الأنسب هو النوع المركب `DATETIME`، خصوصًا في التطبيقات الحديثة.

---

## 🧠 **نصائح عامة:**

- اختار النوع المناسب حسب **طبيعة البيانات** و**أداء التطبيق**.
- خليك حذر في الفروق بين قواعد البيانات المختلفة (PostgreSQL ≠ SQL Server).
- لو هتصمم نظام يدعم أكثر من DB، استخدم أدوات نمذجة تسمح بـ "Generic types".

---
## ✅ **ملخص أهم اختيارات Data Types من الفقرة**

---

### 🟢 **اختيارات بسيطة (Simple Choices)**

#### 🧍‍♂️ أسماء الأشخاص (FirstName, LastName, SecurityName)

- استخدم `VARCHAR` لأنه:
    - الطول غير ثابت.
    - ما فيش داعي تحجز طول أكبر من اللازم.

#### 🆔 Middle Initial, Security Code

- استخدم `CHAR` لأنه:
    - الطول ثابت (مثلاً 1 أو 4).
    - غالبًا البيانات هتكون دائمًا بنفس الطول.
#### 📞 أرقام التليفون

- استخدم `CHAR` **وليس INTEGER**، لأن:
    - مش هنحسب بيه.
    - ممكن يحتوي رموز زي: `+`, `*`, `#`.
    - بيعطينا **مرونة أكبر** في التعامل مع تنسيقات مختلفة.
#### 🧠 نصيحة تنظيمية:

- استخدم أطوال قياسية لـ `VARCHAR`:  
    مثال: 20, 50, 100, 250... علشان تكون سهل تتذكرها وقت الكود.

---
### 🟠 **اختيارات أكثر تعقيدًا (More Complicated Choices)**

#### ✅ **CreditRisk**

- مجرد Yes/No → الأفضل:
    
    - `BOOLEAN` أو `BIT`
    - أو أصغر نوع `INTEGER` لو DB ما بتدعمش boolean.
        

#### 💰 **PricePaid**
- نحتاج دقة عالية: مثل 4 أرقام عشرية (مثال: 3.6525).
    - أفضل نوع: `DECIMAL(10, 4)`
    - ليه؟ لأن `FLOAT` ممكن يسبب **مشاكل تقرييب (Rounding errors)**.

#### 🕒 **DatePurchased**

- نحتاج **تاريخ + وقت حتى الدقيقة**.
    - أفضل نوع: `DATETIME`

#### 🎂 **Age**

- ما نخزنش السن مباشرة!
    - الأفضل نخزن **تاريخ الميلاد** (DOB) كـ `DATE`
    - ونحسب السن وقت الحاجة.
    - ليه؟ لأن السن بيتغير لكن تاريخ الميلاد لا.
---
## 🔁 **خلاصة عملية**

|العمود|النوع المقترح|السبب|
|---|---|---|
|FirstName, LastName|VARCHAR(50)|مرن في الطول، وموفر في التخزين|
|MiddleInitial|CHAR(1)|دايمًا حرف واحد|
|PhoneNumber|CHAR(15)|فيه رموز ومش بيتحسب بيه|
|CreditRisk|BOOLEAN / BIT|قيمتين فقط (نعم/لا)|
|PricePaid|DECIMAL(10,4)|دقة عالية ومنع أخطاء التقريب|
|DatePurchased|DATETIME|نحتاج وقت الشراء بالكامل|
|Age|DATE (DOB)|السن بيتغير، الميلاد ثابت|

---
## ✅ **1. Optionality – السماح بالـ NULL**

**يعني: هل ممكن العمود يقبل قيمة فارغة (NULL)؟**

### 🟢 استخدم `NULL` لما:

- تكون القيمة **اختيارية** فعلًا.
- تحب تعرف إذا كان المستخدم **ما دخلش قيمة بنفسه**.
- العمود من نوع `CHAR` ومش عايز تحجز مساحة بدون داعي (زي MiddleInitial).

🔸 مثال:  
لو عمود `MiddleInitial` نوعه `CHAR(1)` وسمحنا بـ NULL، مش هنضطر نملأه بمسافات فاضية لما الشخص معندوش حرف وسط.

---

## ⚠️ **تحذير من NULL**

- لا يمكن استخدامه في المقارنات التقليدية `=`, `<>`, `>`, إلخ.
- لازم تستخدم `IS NULL` أو `IS NOT NULL`.
- بيؤثر على الحسابات والـ JOINS لو مش واخد بالك.

---

## ✅ **2. Default Values – القيم الافتراضية**

**يعني: لو المستخدم مدخلش حاجة، إيه القيمة اللي تتخزن تلقائيًا؟**
### 🟡 استخدم Default لما:

- تكون عايز قيمة دايمًا موجودة حتى لو المستخدم سابها فاضية.
- بس مش فارق معاك إذا كانت من إدخاله أو تلقائيًا.
- القيم ثابتة أو تعتمد على دالة (زي التاريخ الحالي).

🔸 مثال:

```sql
CreditRisk BIT DEFAULT 0
```

- ده معناه إن العميل مش عليه مخاطر افتراضيًا.

🔸 مثال تاني لتاريخ الإنشاء:

```sql
CreateDate DATETIME DEFAULT GETDATE()
```

---
## ⚖️ **NULL vs DEFAULT؟**

|الحالة|الأفضل|
|---|---|
|عايز تعرف المستخدم دخل القيمة؟|NULL|
|محتاج دايمًا قيمة موجودة؟|DEFAULT|
|القيمة ممكن تكون صفر حقيقي؟|NULL (عشان تفرقها عن 0)|
|قيمة التاريخ التلقائي؟|DEFAULT (مع دالة)|

---
## ✏️ **نصيحة في التصميم**

- **لا تستخدم Default = 0** لما تكون القيمة ممكن تكون فعلاً 0!
    - لو حطيت Default 0، مش هتعرف هو دخلها ولا جات تلقائيًا.

---
## ✅ **إيه هي Check Constraints؟**

هي شروط بنضيفها على الأعمدة عشان نمنع إدخال بيانات غير منطقية أو مخالفة لقواعد البزنس.

---
### 🎯 **أمثلة على استخدام Check Constraints:**

- منع القيم السالبة:
    ```sql
    CHECK (PricePaid >= 0)
    ```
    
- السماح بالقيم الموجبة أو NULL:
    ```sql
    CHECK (PricePaid >= 0 OR PricePaid IS NULL)
    ```
    

---

### ⚠️ **ليه بنكتب OR PricePaid IS NULL؟**

لأن **NULL مش بيعدي** في أي مقارنة رياضية:

- `NULL >= 0` بيطلع نتيجته NULL → وده يعني **"false"** في شروط الـ CHECK.
- فلو كتبت شرط من غير `IS NULL`، كده انت **منعت إدخال NULL** حتى لو العمود كان بيقبلها.

---
### 🔧 **فين نكتب الشروط دي؟**

- ممكن تكتبها يدويًا في DDL لما تعمل الجدول.
- أو تستخدم Modeling Tool زي Visio عشان تولدها أوتوماتيك عند بناء قاعدة البيانات.

---
### 📌 **شكل Check Constraint في SQL Server مثلًا:**

```sql
CONSTRAINT SecurityHoldingPricePaid_Chk
CHECK (PricePaid >= 0 OR PricePaid IS NULL)
```

---

### 💡 **نصيحة عملية:**

- **دايمًا فكّر في الـ NULL** لما تكتب CHECK.
- واستخدم الـ constraints في قاعدة البيانات نفسها، **مش بس في التطبيق**، عشان تضمن حماية البيانات من أي مصدر.

---
### ✅ **إيه هو Referential Integrity؟**

هو شرط بيضمن إن أي قيمة في العمود اللي بيحمل **Foreign Key** لازم تكون:

- يا إما **NULL**
- يا إما **موجودة فعلًا** كـ **Primary Key** في الجدول اللي بنشير له

---
### 🧱 مثال عملي (جداول `Orders` و `Customers`):

|Orders (Child Table)|يجب ألا يحتوي `CustomerID` على قيمة غير موجودة في جدول `Customers`.|
|---|---|

```sql
FOREIGN KEY (CustomerID) REFERENCES Customers(CustomerID)
```

---
### 🧯 **المشاكل اللي بيمنعها Referential Integrity:**

1. **Insert Anomaly (خلل أثناء الإدخال)**
    - لو حاولت تدخل order لعميل مش موجود → **هيرفض**.
        
2. **Update Anomaly (خلل في التحديث)**
    - لو حد غير رقم `CustomerID` في جدول `Customers`، البيانات اللي في `Orders` هتبقى مش مربوطة بحد → النظام **يمنع التغيير**.
        
3. **Delete Anomaly (خلل في الحذف)**
    - لو حاولت تحذف عميل عنده طلبات → **هتفشل العملية** لو في بيانات مرتبطة.
        

---
### 💻 **مثال من SQL Server على إنشاء العلاقة:**

```sql
CREATE TABLE PropertyFeature (
  feature_code CHAR(5) NOT NULL,
  property_id CHAR(8) NOT NULL,
  CONSTRAINT propertyfeature_pk PRIMARY KEY (feature_code, property_id),
  CONSTRAINT propertyfeature_fk_featurecode FOREIGN KEY (feature_code) REFERENCES Feature(feature_code),
  CONSTRAINT propertyfeature_fk_propertyid FOREIGN KEY (property_id) REFERENCES Property(property_id)
);
```

---
### ⚠️ **ملحوظة مهمة عن MySQL:**

- مش كل أنظمة قواعد البيانات بت enforce الـ referential integrity.
- MySQL (خاصة في الإصدارات الأقدم أو مع بعض الـ storage engines زي MyISAM) بتسمحلك تكتب العلاقات لكنها **مش بتطبقها فعلًا**، فالمطور لازم يتحمل مسؤولية التأكد من صحة البيانات بنفسه.
    

---
### 🛡️ الخلاصة:

- Referential Integrity بتحميك من إدخال بيانات غير مترابطة، أو من فقدان الربط بين الجداول.
- بتمنع أخطاء شائعة في الـ `INSERT`, `UPDATE`, و `DELETE`.
- وده بيساعدك تبني قواعد بيانات نظيفة وموثوقة ومستقرة.

---
### ✅ أولًا: **النتائج العملية لتطبيق Referential Integrity**

1. **الإدخال (INSERT)**  
    لازم تدخل السجل في **الجدول الأب أولًا** قبل ما تدخل سجل مرتبط في الجدول الابن.
    - مثال: تدخل `Customer` الأول، بعدين `SecurityHolding`.

2. **الحذف (DELETE)**  
    لازم تحذف كل السجلات المرتبطة بالعميل (في `SecurityHolding`) قبل ما تحذفه من جدول `Customer`.

3. **التحديث (UPDATE)**
    - لا تقدر تحدث الـ PK في الجدول الأب **طالما فيه أبناء مرتبطين بيه**.
    - ولا تقدر تحدث الأبناء **إلا بعد تحديث الأب** → وده بيسبب **حالة جمود (stalemate)**.

---
### 🛠️ الحل: **Referential Actions**

- هي أوامر بتحدد **إزاي يتصرف الـ DBMS** لما يحصل تعديل أو حذف في المفتاح الأساسي (PK) اللي عليه علاقات.

---
### 📋 أنواع Referential Actions:

|Referential Action|لما تحدث الأب|لما تحذف الأب|
|---|---|---|
|**RESTRICT** _(افتراضي)_|يمنع التحديث|يمنع الحذف|
|**CASCADE**|يعدل كل الأبناء تلقائيًا|يحذف كل الأبناء تلقائيًا|
|**SET NULL**|يخلي FK في الأبناء = NULL|يخلي FK في الأبناء = NULL|

---
### ❗ ملاحظات مهمة:

- **CASCADE** مفيد جدًا لما يكون منطقي حذف كل الأبناء لما الأب يتحذف (زي حذف مجلد فيه ملفات).
    - بدل 3 أوامر (`check` → `delete children` → `delete parent`) بتعمل كل حاجة في أمر واحد.
    - مثال: `ON DELETE CASCADE`.

- **لكن** في مواقف تانية **استخدام CASCADE خطر**.
    - مثال: موظف يدير مشاريع، لو اتحذف الموظف هتخسر كل المشاريع تبعًا له!
    - في الحالة دي، **RESTRICT** أفضل، وده يخليك:
        - تحوّل إدارة المشروع لموظف تاني.
        - أو تاخد قرار واعي قبل حذف أي حاجة.
    
- بعض أنظمة قواعد البيانات **مش بتدعم `SET NULL`** مباشرة (زي Oracle أحيانًا)، لكن ممكن تنفذها بـ **triggers**.

---
### 🧠 الخلاصة:

- **Referential Integrity** تحمي ترابط البيانات، لكن ممكن تعقد العمليات زي التعديل والحذف.
- **Referential Actions** بتديك تحكم كامل في السلوك.
- اختار نوع الـ action بعناية حسب سياق البيانات واستخدامك في التطبيق.

---
### ✅ إيه هو Denormalization؟

- هو إنك **تتعمّد تكرار البيانات (introduce redundancy)** في قاعدة البيانات علشان تحسّن الأداء.
- يعني تكسر شوية قواعد التطبيع (Normalization) اللي اتعلمناها في الفصول اللي فاتت.

---
### 🧠 ليه نعمل كده؟

- في بعض الحالات، **الاستعلامات (SELECT)** بتتكرر بشكل كثيف جدًا، وبتكون أغلب شغل التطبيق هو قراءة بيانات.
- لو كنا ملتزمين 100% بالتطبيع، فهتضطر قاعدة البيانات تعيد حساب القيم (زي `COUNT`, `JOIN`, `GROUP BY`) كل مرة.
- فـ **التكرار المقصود** للبيانات (زي إنك تخزن عدد الكتب عند كل ناشر بدل ما تعدهم كل مرة) ممكن:
    - **يقلل الحمل على السيرفر**
    - **يسرّع استعلامات القراءة**

---
### ⚖️ لكن فين المشكلة؟

- **Denormalization** بيؤدي إلى:
    - بيانات مكررة → احتمال **عدم التناسق (Inconsistency)**
    - محتاج **معالجة إضافية** وقت التحديث أو الإدخال (لأنك لازم تحدّث كل النسخ المكررة)

---
### 📌 إمتى أقرر أعمل Denormalization؟

1. **بعد ما تبني قاعدة بيانات "مطَبّعة تمامًا" (Well-normalized).**
2. **وتختبر أدائها في ظروف حقيقية قريبة من الإنتاج (realistic load).**
3. **لو الأداء مش مرضي، ساعتها بس فكّر في denormalization.**

---
### 👨‍💻 حالات خاصة:

- مثلًا، لو عندك ميزة في موقعك زي:
    > "العملاء اللي اشتروا X اشتروا أيضًا Y"
    
    فممكن تحتاج تسجّل وتحلّل عادات الشراء.
- لو حسبت كل حاجة في لحظتها → بطيء جدًا.

- الأفضل إنك:
    
    - تجمع البيانات بشكل دوري (batch job)،
    - وتخزن النتائج مسبقًا (denormalized summary tables)،
    - وتستخدمها عند عرض التوصيات.

---
### 🧾 الخلاصة:

|المعيار|Normalized|Denormalized|
|---|---|---|
|الأداء عند SELECT|أبطأ (لأنه يحسب وقتها)|أسرع (بيانات جاهزة)|
|الأداء عند INSERT/UPDATE|أسرع|أبطأ (لأنك بتحدّث أكتر من مكان)|
|الاتساق (Consistency)|مضمون|محتاج اهتمام إضافي|
|متى يُستخدم؟|دايمًا في البداية|فقط بعد اختبار وتحليل الأداء|

---
### 🗣️ ملحوظة مهمة:

> "Denormalization is **not bad** – it’s just a trade-off."  
> الهدف مش كسر القواعد، لكن الموازنة بين **الأداء** و **سلامة البيانات**.

سؤال ممتاز! علشان تعمل **Denormalization**، فيه شوية طرق شائعة بتختلف حسب نوع البيانات والمشكلة اللي بتحاول تحلها. خليني أشرحلك **الطرق الأساسية اللي ممكن تستخدمها لعمل denormalization في قاعدة البيانات**:

---
## ✅ 1. **إضافة عمود مشتق (Derived Column)**

بدل ما تحسب قيمة كل مرة، تخزنها في الجدول.
**مثال:**
بدل ما كل مرة تعمل:

```sql
SELECT COUNT(*) FROM Book WHERE PublisherID = 1;
```

ممكن تضيف عمود اسمه `BookCount` في جدول `Publisher`، وتحدّثه عند إضافة أو حذف كتاب.

```sql
ALTER TABLE Publisher ADD BookCount INT DEFAULT 0;
```

وتحدّثه بالكود (أو Trigger):

```sql
UPDATE Publisher
SET BookCount = BookCount + 1
WHERE PublisherID = 1;
```

---
## ✅ 2. **الدمج بين جدولين (Table Merge / Flattening)**

لو عندك جدولين بينهم علاقة One-to-One أو Many-to-One، ممكن تدمجهم في جدول واحد.

**مثال:**

بدل ما يكون عندك:

```plaintext
User        |       Address
------------|---------------------
UserID (PK) | AddressID (PK)
Name        | UserID (FK)
            | City
            | Country
```

ممكن تعمل جدول واحد:

```plaintext
User
----------------------------
UserID (PK)
Name
City
Country
```

ده بيقلل الـ joins، ويزود السرعة في الاستعلامات، خصوصًا في صفحات الـ Profile.

---
## ✅ 3. **جداول مُجمّعة (Summary Tables)**
لو عندك استعلامات تقارير أو تجميعات بتتكرر كتير، اعمل جدول خاص للنتايج دي.
**مثال:**

```sql
CREATE TABLE DailySalesSummary (
  SaleDate DATE PRIMARY KEY,
  TotalAmount DECIMAL(10,2),
  TotalOrders INT
);
```

وبتحدّث الجدول ده يوميًا باستخدام Job أو Scheduled Task (أو Trigger إذا كان الحجم صغير).

---
## ✅ 4. **تخزين البيانات الجاهزة للاستعراض (Precomputed Values)**

بدل ما تحسب البيانات في وقت العرض (runtime)، احسبها مسبقًا وخزنها.

**مثال:**  
لو عندك نظام توصيات (X اشترى Y)، احسبه offline وخزنه في جدول:

```plaintext
Recommendations
----------------------------
ProductID     | RecommendedProductID
```

---
## ⚠️ ملاحظات مهمة:

- **لازم تراقب التحديثات**: أي قيمة مشتقة لازم تتحدّث وقت ما البيانات الأصلية تتغير.
- **ينفع تستخدم Triggers** علشان تربط بين التغيير والتحديث التلقائي.
- **ينفع تستخدم Batch Jobs** (مثلاً كل يوم بالليل) لتحديث الجداول المجمّعة.
- **تابع الأداء قبل وبعد**: دايمًا جرّب وشوف فرق الأداء علشان تعرف إذا كانت الخطوة دي مفيدة فعلًا.